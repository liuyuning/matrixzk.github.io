<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Matrixzk]]></title>
  <link href="http://matrixzk.github.io/atom.xml" rel="self"/>
  <link href="http://matrixzk.github.io/"/>
  <updated>2014-10-30T12:55:35+08:00</updated>
  <id>http://matrixzk.github.io/</id>
  <author>
    <name><![CDATA[matrixzk]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS8 Day-by-Day :: Day 2 :: Sharing 扩展]]></title>
    <link href="http://matrixzk.github.io/blog/20141029/ios8-day-by-day-day-2-sha-kuo-zhan/"/>
    <updated>2014-10-29T19:16:20+08:00</updated>
    <id>http://matrixzk.github.io/blog/20141029/ios8-day-by-day-day-2-sha-kuo-zhan</id>
    <content type="html"><![CDATA[<p>本文译自 : <a href="http://www.shinobicontrols.com/blog/posts/2014/07/21/ios8-day-by-day-day-2-sharing-extension">iOS8 Day-by-Day :: Day 2 :: Sharing Extension</a></p>

<ul id="markdown-toc">
  <li><a href="#section">简介</a></li>
  <li><a href="#share-extention">创建一个分享扩展(Share Extention)</a></li>
  <li><a href="#section-1">编译，运行和调试</a></li>
  <li><a href="#section-2">指定可被分享的内容</a></li>
  <li><a href="#validating">验证(Validating)用户输入</a></li>
  <li><a href="#section-3">在扩展内部上传</a></li>
  <li><a href="#section-4">提取一张图片并上传</a></li>
  <li><a href="#section-5">执行后台上传</a></li>
  <li><a href="#section-6">总结</a></li>
</ul>

<h2 id="section">简介</h2>

<p>iOS8的一个<strong>重大</strong>新特色是引入了对扩展(<code>Extention</code>)的支持。通过它，开发者可以使用自己的功能和特色来增强操作系统的功能，包括第三方应用和苹果自家内置的应用。
有如下6种扩展可适用于iOS：</p>

<!-- more -->

<ul>
  <li>Today screen widgets</li>
  <li>Share extensions</li>
  <li>Actions</li>
  <li>Photo editing</li>
  <li>Storage providers</li>
  <li>Custom keyboards</li>
</ul>

<p>在以后的系列博文中我们会讲到上述某些扩展，但今天的主题是Sharing Extentions(分享扩展)。</p>

<p>Sharing Extentions给app的开发者一个将自己的app的icon展示在系统公共的分享面板(<code>share-sheet</code>)上的机会，然后处理用户所请求分享的内容。这就意味着你可以对系统展示的分享列表(比如 Twitter, Flickr, Sina Weibo 等)进行补充。</p>

<p>先提个醒，这个主题并不简单。扩展的实现原理是非常复杂的。本文将向你介绍一些主要的使用场景，但请注意你可以构造更加漂亮的视觉展现。苹果在这方面提供了一些很棒的资源，当你被任何难点卡住的时候都可以阅读以下他们。</p>

<h2 id="share-extention">创建一个分享扩展(Share Extention)</h2>

<h2 id="section-1">编译，运行和调试</h2>

<h2 id="section-2">指定可被分享的内容</h2>

<h2 id="validating">验证(Validating)用户输入</h2>

<h2 id="section-3">在扩展内部上传</h2>

<h2 id="section-4">提取一张图片并上传</h2>

<h2 id="section-5">执行后台上传</h2>

<h2 id="section-6">总结</h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8 Day-by-Day :: Day1 :: Swift概述]]></title>
    <link href="http://matrixzk.github.io/blog/20141028/ios8-day-by-day-day1-swiftgai-shu/"/>
    <updated>2014-10-28T20:38:03+08:00</updated>
    <id>http://matrixzk.github.io/blog/20141028/ios8-day-by-day-day1-swiftgai-shu</id>
    <content type="html"><![CDATA[<p>本文译自 : <a href="http://www.shinobicontrols.com/blog/posts/2014/07/17/ios8-day-by-day-day-1-blaggers-guide-to-swift">iOS8 Day-by-Day :: Day 1 :: Blagger’s Guide to Swift</a></p>

<ul id="markdown-toc">
  <li><a href="#section">简介</a></li>
  <li><a href="#initialisation">初始化(Initialisation)</a></li>
  <li><a href="#mutability">可变性(Mutability)</a></li>
  <li><a href="#strong-typinganyobject">强类型(<code>Strong Typing</code>)和<code>AnyObject</code></a></li>
  <li><a href="#protocol-conformance">协议的一致性(Protocol Conformance)</a></li>
  <li><a href="#enums">枚举(Enums)</a></li>
  <li><a href="#section-1">总结</a></li>
</ul>

<h2 id="section">简介</h2>

<p>今年的WWDC令人印象深刻，除了宣布<code>iOS8</code>，苹果还向我们介绍了一门新的编程语言–<code>Swift</code>。<code>Swift</code>和<code>objective-C</code>有很大的区别，它是强类型(<code>Strongly-typed</code>)的，并且包含有很多现代编程语言的特性。</p>

<p>出于对新兴事物强大的热情和兴趣，这个博客系列将全程使用Swift。现在市面上已经有了很丰富的资源向我们介绍如何使用Swift，以及它是如何与Cocoa框架交互的。事实上，通过阅读如下官方文档开始你的Swift之旅是一个非常明智的选择:</p>

<!-- more -->

<ul>
  <li><a href="https://itunes.apple.com/us/book/the-swift-programming-language/id881256329?mt=11&amp;ls=1">The Swift Programming Language</a></li>
  <li><a href="https://itunes.apple.com/us/book/using-swift-cocoa-objective/id888894773?mt=11&amp;ls=1">Using Swift with Cocoa and Objective-C</a></li>
</ul>

<p>你同时应该关注官方的<a href="https://developer.apple.com/swift/blog/">Swift Blog</a>，以及Apple提供的一些其他的官方<a href="https://developer.apple.com/swift/resources/">资源</a>。</p>

<p>由于已经有了很多很好的资源向我们介绍如何使用<code>Swift</code>，因此接下来我们不会涉及过多的基础内容，但我们会着重向你介绍在初次使用Swift的过程中可能会遇到的一些重要的陷阱和潜在的痛点，特别是与系统的框架相关的。</p>

<p>我会在一个<code>Xcode 6 playground</code>里向你展示以下所介绍的示例代码，你可以通过<code>ShinobiControls</code>的Github<a href="https://github.com/ShinobiControls/iOS8-day-by-day">得到它</a>。</p>

<p>如果对本文有任何疑问，或者建议添加一些其他相关内容，你可以通过在下边添加评论或通过<a href="https://twitter.com/iwantmyrealname">@iwantmyrealname</a>在<code>twitter</code>上告诉我，我会在本系列文章中对其持续跟进。</p>

<h2 id="initialisation">初始化(Initialisation)</h2>

<p>Swift正式引入了与对象初始化相关的概念，包括<code>designated initialiser</code>(指定初始化方法)和<code>convenience initialiser</code>(便利初始化方法)，以及在对一个对象初始化的过程中以指定的顺序调用一系列初始化方法。近期我将会通过本系列文章中的一篇来详细介绍Swift的初始化是如何工作的，以及这将会对你所写的objective-C部分的代码造成哪些影响，敬请关注。</p>

<p>Swift和objective-C在初始化方面的另一个重要区别是返回值和初始化失败的情况。在objective-C中的初始化方法大概像这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="objective-c"><span class="line"><span class="p">-</span> <span class="p">(</span><span class="kt">instancetype</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
</span><span class="line">    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
</span><span class="line">    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">// Do some stuff</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line">    <span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>在Swift中是这样：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">init</span> <span class="p">{</span>
</span><span class="line">    <span class="n">variableA</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class="line">    <span class="p">...</span>
</span><span class="line">    <span class="nb">super</span><span class="p">.</span><span class="k">init</span><span class="p">()</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>注意，objective-C的初始化方法负责创建(Create)并且返回<code>self</code>，但在Swift对应的场景中却不存在<code>return</code>语句。这就意味着，在Swift中你无法像objC那样在初始化失败时返回一个<code>nil</code>对象。</p>

<p>或许Swift在不久后正式发布时会解决掉这个问题，但现在唯一可以绕过这个问题的解决方案是使用一个返回可选类型(<code>optional type</code>)的类方法(<code>class method</code>)：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">class</span> <span class="n">MyClass</span> <span class="p">{</span>
</span><span class="line">    <span class="k">class</span> <span class="k">func</span> <span class="n">myFactoryMethod</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">MyClass</span><span class="o">?</span> <span class="p">{</span>
</span><span class="line">        <span class="p">...</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>有趣的是，objective-C<code>APIs</code>中的工厂方法(<code>factory method</code>)在Swift中被转换成了初始化方法(<code>initialiser</code>)，因此上述解决方案并不完美。但是在Swift语言解决这个问题之前，这是处理初始化失败的情况的唯一选择。</p>

<h2 id="mutability">可变性(Mutability)</h2>

<p>对于Cocoa开发者来说，(不)可变性(<code>(im)mutability</code>)并不是一个新的概念。我们已经能够在适当的场景使用<code>NSArray</code>或其对应的可变类型<code>NSMutableArray</code>，而且我们也知道应该尽可能得优先选用相应的不可变(<code>immutable</code>)类型。但Swift把这一概念提升到了一个新的高度，而且把不可变性(<code>immutability</code>)作为一个基本概念融入到了这门语言的血液。</p>

<p>Swift中用关键字<code>let</code>来定义一个不可变变量(<code>immutable variable</code>)，即你不能改变其所代表的内容。
举个栗子：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">()</span>
</span><span class="line"><span class="n">a</span> <span class="o">=</span> <span class="n">MySecondClass</span><span class="p">()</span> <span class="c1">// 不允许</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这就意味着你不能对一个由关键字<code>let</code>定义的变量重新赋值(<code>redefine</code>)。取决于对象的类型，对象自身也可能是不可变的(<code>immutable</code>)。如果是值类型(<code>value type</code>)，比如<code>struct</code>，它也将是不可变的。如果是引用类型(<code>reference type</code>)，比如<code>class</code>，那么它将是可变的。(译者注：这里所说的对象自身是指对象内部的属性)</p>

<p>为了说明这一点，我们来看如下结构体(<code>struct</code>)：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">struct</span> <span class="n">MyStruct</span> <span class="p">{</span>
</span><span class="line">    <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">12</span>
</span><span class="line">    <span class="k">var</span> <span class="nl">u</span><span class="p">:</span> <span class="n">String</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果我们用关键字<code>var</code>来定义一个变量<code>struct1</code>，可以看到如下结果：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">var</span> <span class="n">struct1</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class="line"><span class="n">struct1</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">13</span> <span class="c1">// 错误: t 是一个不可变的属性</span>
</span><span class="line"><span class="n">struct1</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="s">&quot;GoodBye&quot;</span>
</span><span class="line"><span class="n">struct1</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;You&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>你可以改变<code>u</code>属性，因为它是由<code>var</code>定义的，你也可以重新给变量<code>struct1</code>赋值(<code>redefine</code>)，同样是因为它是由<code>var</code>定义的。但是属性<code>t</code>是不能被改变的，因为它被定义为<code>let</code>。下面我们来看下用关键字<code>let</code>来定义一个结构体(<code>struct</code>)的实例将会发生什么：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">let</span> <span class="n">struct2</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;World&quot;</span><span class="p">)</span>
</span><span class="line"><span class="n">struct2</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="s">&quot;Planet&quot;</span> <span class="c1">// 错误: struct2 是不可变的</span>
</span><span class="line"><span class="n">struct2</span> <span class="o">=</span> <span class="n">MyStruct</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;Defeat&quot;</span><span class="p">)</span> <span class="c1">// 错误: struct2 是不可变的引用</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里不仅不能改变<code>struct2</code>变量，也不能改变这个结构体的内容(比如其属性<code>u</code>)。这是因为结构体(<code>struct</code>)是<strong>值类型</strong>(<code>value type</code>)。</p>

<p>同样的场景，对于一个类(<code>class</code>)来说就有一些微妙的差别：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">class</span> <span class="n">MyClass</span> <span class="p">{</span>
</span><span class="line">    <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="mi">12</span>
</span><span class="line">    <span class="k">var</span> <span class="nl">u</span><span class="p">:</span> <span class="n">String</span>
</span><span class="line">
</span><span class="line">    <span class="k">init</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="n">Int</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="n">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">        <span class="nb">self</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">t</span>
</span><span class="line">        <span class="nb">self</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="n">u</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>根据使用objective-C的经验，将变量定义为<code>var</code>所表现出来的行为或许你并不感到奇怪：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">var</span> <span class="n">class1</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class="line"><span class="n">class1</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="mi">13</span> <span class="c1">// 错误: t 是一个不可变的属性</span>
</span><span class="line"><span class="n">class1</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="s">&quot;GoodBye&quot;</span>
</span><span class="line"><span class="n">class1</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;You&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>你不仅可以改变引用本身，而且可以改变所有使用<code>var</code>定义的变量，但是却不能改变任何一个使用<code>let</code>定义的变量。接下来用<code>let</code>来定义一个类实例，我们来对比一下他们的表现有何不同：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">let</span> <span class="n">class2</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;World&quot;</span><span class="p">)</span>
</span><span class="line"><span class="n">class2</span><span class="p">.</span><span class="n">u</span> <span class="o">=</span> <span class="s">&quot;Planet&quot;</span> <span class="c1">// 正确</span>
</span><span class="line"><span class="n">class2</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="nl">t</span><span class="p">:</span> <span class="mi">11</span><span class="p">,</span> <span class="nl">u</span><span class="p">:</span> <span class="s">&quot;Geoid&quot;</span><span class="p">)</span> <span class="c1">// 错误: class2 是一个不可改变的引用</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里你不能改变这个引用(<code>reference</code>)自身，但是<strong>可以</strong>改变这个类中的任何一个使用<code>var</code>定义的属性。这是因为类是<strong>引用类型</strong>(<code>reference type</code>)。</p>

<p>上述现象很容易理解，并且在该语言的参考书籍有详尽的解释。但是当我们把目光转向Swift的集合类型(<code>collection types</code>)时，上述概念就容易混淆了。</p>

<p><code>NSArray</code>是引用类型。也就是说当你创建一个<code>NSArray</code>的实例时，你创建了一个对象，并且代表该对象的变量是一个指向该数组在内存中的地址的指针，也因此在objective-C中定义该变量时要在前边标注一个星号。如果你回顾一下之前所学的关于<code>var</code>和<code>let</code>的引用类型和和值类型的语义(<code>semantics</code>)，可能会想象出他们会有怎样的行为表现。事实上，如果你需要一个NSArray的可变的版本，那不得不用另一个类 – <code>NSMutableArray</code>。</p>

<p>Swift的数组并不像这样，它们是值类型而非引用类型。这就意味着它们的行为更像是结构体(<code>struct</code>)而不是类(<code>class</code>)。因此，关键字<code>var</code>或<code>let</code>不仅指定了变量能否被重新定义(<code>redefined</code>)，还决定了所创建的数组是否是可变的。</p>

<p>一个用<code>var</code>定义的数组不仅可以被重新赋值(<code>reassigned</code>)，还可以改变其元素：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">var</span> <span class="n">array1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
</span><span class="line"><span class="n">array1</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>  <span class="c1">// [1,2,3,4,5]</span>
</span><span class="line"><span class="n">array1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">27</span>    <span class="c1">// [27,2,3,4,5]</span>
</span><span class="line"><span class="n">array1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>    <span class="c1">// [3,2]</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>但是对于一个被定义为<code>let</code>的数组，既不能对其重新赋值，也不能改变其元素：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">let</span> <span class="n">array2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
</span><span class="line"><span class="n">array2</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">// 错误: array2 是不可变的</span>
</span><span class="line"><span class="n">array2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">36</span>   <span class="c1">// 错误: array2 是不可变的</span>
</span><span class="line"><span class="n">array2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>   <span class="c1">// 错误: 一个不可变的引用不能被再次赋值</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这是一个非常容易引起混淆的地方。它不仅完全改变了我们对集合的可变性(<code>mutability</code>)的理解，同时也混淆了之前明显不同的两个概念。也许在不久之后的Swift的正式发行版本会改变这种行为，让我们拭目以待。</p>

<p>由此导致的一个必然结果是，由于这里的数组是值类型，因此它们传递的是一个副本(<code>copy</code>)。<code>NSArray</code>实例总是通过引用(<code>reference</code>)传递，因此一个拿到某个<code>NSArray</code>类型指针的方法将指向和之前相同的一块内存空间。如果你给某方法传一个Swift数组，它拿到的将是该数组的一份拷贝。数组中所存放对象的类型决定是深拷贝还是浅拷贝。写代码时要警惕这里！</p>

<h2 id="strong-typinganyobject">强类型(<code>Strong Typing</code>)和<code>AnyObject</code></h2>

<p>强类型(<code>Strong Typing</code>)被视为Swift的一个重大特性，它能顾及到更加安全的代码，因为objective-C中运行时才可能抛出的异常如今在编译阶段就能将其捕获。</p>

<p>非常棒，但是，当Swift和objective-C系统框架一起使用时，你会发现很多<code>AnyObject</code>类型。它在Swift中相当于objective-C中的<code>nil</code>。在很多方面，<code>AnyObject</code>给人的感觉不太像Swift的风格(<code>un-Swift-like</code>)。它允许你调用<strong>任何</strong>它能找到的方法，但这样会导致运行时异常。实际上，它的作用几乎和objective-C中的<code>id</code>一模一样。不同的是如果某些属性或不含参数的方法不存在于某<code>AnyObject</code>，将会返回<code>nil</code>：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">let</span> <span class="nl">myString</span><span class="p">:</span> <span class="n">AnyObject</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span>
</span><span class="line"><span class="n">myString</span><span class="p">.</span><span class="n">cornerRadius</span> <span class="c1">// Returns nil</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>为了以一种更加Swift的方式与<code>Cocoa APIs</code>协同工作，你会经常看到如下形式的代码：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">func</span> <span class="n">someFunc</span><span class="p">(</span><span class="nl">parameter</span><span class="p">:</span> <span class="n">AnyObject</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyObject</span><span class="o">!</span> <span class="p">{</span>
</span><span class="line">    <span class="k">if</span> <span class="k">let</span> <span class="n">castedParameter</span> <span class="o">=</span> <span class="n">parameter</span> <span class="kt">as</span><span class="o">?</span> <span class="bp">NSString</span> <span class="p">{</span>
</span><span class="line">        <span class="c1">// Now I know I have a string :)</span>
</span><span class="line">        <span class="p">...</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果你清楚的知道将要接收的是一个String类型的参数，就不必那么小心翼翼地对这个传参进行安全的类型转换了：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">let</span> <span class="n">castedParameter</span> <span class="o">=</span> <span class="n">parameter</span> <span class="kt">as</span> <span class="bp">NSString</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>其实对一个数组类型的传参进行安全的类型转换很简单。由于<code>NSArray</code>不支持泛型(<code>generics</code>)，所以你从Cocoa框架接收来的数组都是<code>[AnyObject]</code>类型的。然而，几乎无一例外的，objective-C中同一个数组中的元素都是相同的类型，而且在当前情形下还都是已知的类型。你可以用如下语法对整个传参过来的数组进行处理：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">func</span> <span class="nf">someArrayFunc</span><span class="p">(</span><span class="nl">parameter</span><span class="p">:</span> <span class="p">[</span><span class="n">AnyObject</span><span class="p">]</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span><span class="line">    <span class="k">let</span> <span class="n">newArray</span> <span class="o">=</span> <span class="n">parameter</span> <span class="kt">as</span> <span class="p">[</span><span class="n">String</span><span class="p">]</span>
</span><span class="line">    <span class="c1">// Do something with your strings :)</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<h2 id="protocol-conformance">协议的一致性(Protocol Conformance)</h2>

<p>Swift中的<code>protocol</code>(协议)很好理解，以如下方式定义：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">protocol</span> <span class="n">MyProtocol</span> <span class="p">{</span>
</span><span class="line">    <span class="k">func</span> <span class="n">myProtocolMethod</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们经常需要检测一个对象是否符合某个特定的协议(protocol)，你可以这样做：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">if</span> <span class="k">let</span> <span class="n">class1AsMyProtocol</span> <span class="o">=</span> <span class="n">class1</span> <span class="kt">as</span><span class="o">?</span> <span class="n">MyProtocol</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// We&#39;re in</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然而这样做有一个错误，因为要想检查一个协议的一致性(<code>conformance</code>)，这个协议必须是一个objective-C的协议，并且在开头用<code>@objc</code>标注：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="p">@</span><span class="n">objc</span> <span class="k">protocol</span> <span class="n">MyNewProtocol</span> <span class="p">{</span>
</span><span class="line">    <span class="k">func</span> <span class="n">myProtocolMethod</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span>
</span><span class="line"><span class="p">}</span>
</span><span class="line">
</span><span class="line"><span class="k">if</span> <span class="k">let</span> <span class="n">class1AsMyNewProtocol</span> <span class="o">=</span> <span class="n">class1</span> <span class="kt">as</span><span class="o">?</span> <span class="n">MyNewProtocol</span> <span class="p">{</span>
</span><span class="line">    <span class="c1">// We&#39;re in</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这里可能比你想象的要麻烦，因为为了给一个协议标记为<code>@objc</code>，它所有的属性和方法返回值类型都要能够被objective-C识别。这就意味着即使你要加载一些你认为只需要专注于Swift的类，那可能依然需要将其标注为<code>@objc</code>。</p>

<h2 id="enums">枚举(Enums)</h2>

<p>Swift中的枚举(<code>Enums</code>)异常强大。它不仅可以有关联的(<code>associated</code>)值(并且他们可以是不同的类型)，而且还可以定义函数。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
<span class="line-number">7</span>
<span class="line-number">8</span>
<span class="line-number">9</span>
<span class="line-number">10</span>
<span class="line-number">11</span>
<span class="line-number">12</span>
<span class="line-number">13</span>
<span class="line-number">14</span>
<span class="line-number">15</span>
<span class="line-number">16</span>
<span class="line-number">17</span>
<span class="line-number">18</span>
<span class="line-number">19</span>
<span class="line-number">20</span>
<span class="line-number">21</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">enum</span> <span class="n">MyEnum</span> <span class="p">{</span>
</span><span class="line">    <span class="k">case</span> <span class="n">FirstType</span>
</span><span class="line">    <span class="k">case</span> <span class="n">IntType</span> <span class="p">(</span><span class="n">Int</span><span class="p">)</span>
</span><span class="line">    <span class="k">case</span> <span class="n">StringType</span> <span class="p">(</span><span class="n">String</span><span class="p">)</span>
</span><span class="line">    <span class="k">case</span> <span class="n">TupleType</span> <span class="p">(</span><span class="n">Int</span><span class="p">,</span> <span class="n">String</span><span class="p">)</span>
</span><span class="line">
</span><span class="line">    <span class="k">func</span> <span class="n">prettyFormat</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">String</span> <span class="p">{</span>
</span><span class="line">        <span class="k">switch</span> <span class="nb">self</span> <span class="p">{</span>
</span><span class="line">            <span class="k">case</span> <span class="p">.</span><span class="nl">FirstType</span><span class="p">:</span>
</span><span class="line">                <span class="k">return</span> <span class="s">&quot;No params&quot;</span>
</span><span class="line">            <span class="k">case</span> <span class="p">.</span><span class="n">IntType</span><span class="p">(</span><span class="k">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class="line">                <span class="k">return</span> <span class="s">&quot;One param: \(value)&quot;</span>
</span><span class="line">            <span class="k">case</span> <span class="p">.</span><span class="n">StringType</span><span class="p">(</span><span class="k">let</span> <span class="n">value</span><span class="p">)</span><span class="o">:</span>
</span><span class="line">                <span class="k">return</span> <span class="s">&quot;One param: \(value)&quot;</span>
</span><span class="line">            <span class="k">case</span> <span class="p">.</span><span class="n">TupleType</span><span class="p">(</span><span class="k">let</span> <span class="n">v1</span><span class="p">,</span> <span class="k">let</span> <span class="n">v2</span><span class="p">)</span><span class="o">:</span>
</span><span class="line">                <span class="k">return</span> <span class="s">&quot;Some params: \(v1), \(v2)&quot;</span>
</span><span class="line">            <span class="k">default</span><span class="o">:</span>
</span><span class="line">                <span class="k">return</span> <span class="s">&quot;Nothing to see here&quot;</span>
</span><span class="line">        <span class="p">}</span>
</span><span class="line">    <span class="p">}</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>这点确实强大。可以像如下这样使用它：</p>

<div class="bogus-wrapper"><notextile><figure class="code"><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class="swift"><span class="line"><span class="k">var</span> <span class="n">enum1</span> <span class="o">=</span> <span class="n">MyEnum</span><span class="p">.</span><span class="n">FirstType</span>
</span><span class="line"><span class="n">enum1</span><span class="p">.</span><span class="n">prettyFormat</span><span class="p">()</span> <span class="c1">// &quot;No params&quot;</span>
</span><span class="line"><span class="n">enum1</span> <span class="o">=</span> <span class="p">.</span><span class="n">TupleType</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="s">&quot;Hello&quot;</span><span class="p">)</span>
</span><span class="line"><span class="n">enum1</span><span class="p">.</span><span class="n">prettyFormat</span><span class="p">()</span> <span class="c1">// &quot;Some params: 12, Hello&quot;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>我们需要通过一些练习来探索一下怎样才能很好的利用这些强大之处。具体你能用它来做什么这里提供一个参考 — Swift中的可选系统(<code>optionals system</code>)就是以枚举为基础实现的。</p>

<h2 id="section-1">总结</h2>

<p>Swift真的很强大。我们需要一段时间的练习来达到最佳实践，并且通过Swift中某些特性和花样来解决一些在objective-C的限制下所解决不了的问题。本文简要介绍了一些在从objective-C向Swift过渡的过程中通常容易引起混淆的地方，不要被这些吓到。本系列博文的所有相关工程都是用Swift写的，而且在大多数情况下都很容易理解。本文所提及的所有示例代码都包含在我们所提供了一个<code>playground</code>文件中，你可以通过<a href="https://github.com/ShinobiControls/iOS8-day-by-day">github.com/ShinobiControls/iOS8-day-by-day</a>获取它。
如果你对本文所涉及的内容有任何疑问，或者有添加或修改的建议，请联系我。你可以在下边给我留言，或者twitte我<a href="https://twitter.com/iwantmyrealname">@iwantmyrealname</a>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Octopress搭建基于Github Pages个人博客的详细过程及原理分析]]></title>
    <link href="http://matrixzk.github.io/blog/20141020/shi-yong-octopressda-jian-ji-yu-github-pagesge-ren-bo-ke-de-xiang-xi-guo-cheng-ji-yuan-li-fen-xi/"/>
    <updated>2014-10-20T21:55:36+08:00</updated>
    <id>http://matrixzk.github.io/blog/20141020/shi-yong-octopressda-jian-ji-yu-github-pagesge-ren-bo-ke-de-xiang-xi-guo-cheng-ji-yuan-li-fen-xi</id>
    <content type="html"><![CDATA[<p>前两天图省事，让一位梦想通过博客改变世界的<a href="http://droidyue.com/">小伙伴</a>帮我搭建了一个基于<a href="https://pages.github.com/">Github Pages</a>的个人博客，使用的是<a href="http://octopress.org/">Octopress</a>静态博客引擎。之后博客虽然能跑起来，但面对繁杂的目录结构和分支，我却怎么也理不清其中的原理。之所以说目录结构繁杂，是因为根据<code>octopress</code>的<a href="http://octopress.org/docs/">官方文档</a>描述，我简直在两者之间找不到多少交集(事后证明有些目录和分支确实冗余)。但它却能正常工作，这激起了我强烈的好奇心，索性就把它全删了，并根据官方文档重新搭建了一次。之后又根据<code>Rakefile</code>文件内容弄清楚了整个搭建过程和每个<code>rake</code>命令的作用。看着Github上清秀的远程仓库目录和知根知底的本地目录结构，顿时心旷神怡，感觉整个世界都敞亮了。所以说，要想搞懂某件事，就把脚伸出去，把鞋子弄湿。说了这么多废话，下面开始进入主题。</p>

<p>PS.以下内容新手可以选择性参考，大神请绕道，谢谢 :]</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">准备工作</a></li>
  <li><a href="#section-1">搭建过程概述</a>    <ul>
      <li><a href="#setupoctopress">设置(Setup)Octopress</a></li>
      <li><a href="#deploygithub-pages">部署(Deploy)到Github Pages</a></li>
      <li><a href="#section-2">下面来简单介绍一下怎么新建一篇文章</a></li>
    </ul>
  </li>
  <li><a href="#section-3">搭建过程详解</a>    <ul>
      <li><a href="#rake-install">rake install</a></li>
      <li><a href="#rake-setupgithubpages">rake setup_github_pages</a></li>
      <li><a href="#rake-generate">rake generate</a></li>
      <li><a href="#rake-preview">rake preview</a></li>
      <li><a href="#rake-deploy">rake deploy</a></li>
      <li><a href="#github-pagessource">生成Github Pages远程库的source分支</a></li>
      <li><a href="#rake-newposthello-world">rake new_post[“Hello World”]</a></li>
    </ul>
  </li>
</ul>

<h2 id="section">准备工作</h2>

<p>首先强调一下，<code>Octopress</code>是一个为hacker们准备的博客框架，你应该对<code>shell</code>命令有亲切感，并且对基础的<a href="http://git-scm.com/">Git</a>知识有所了解，否则Octopress可能不适合你。不过没关系，只要你有足够的热情，上述都是次要的。</p>

<p>开始之前，请确保你已安装了<code>Git</code>和<code>Ruby 1.9.3</code>及以上版本。如果Ruby版本过低，可以使用<a href="https://github.com/sstephenson/rbenv">rbenv</a>或<a href="http://rvm.io/">RVM</a>进行升级。个人推荐使用<code>RVM</code>。</p>

<h2 id="section-1">搭建过程概述</h2>

<p>如果上述的Git和Ruby环境都准备好了，顺次执行下述各命令就能很快搭建成功。关于部署到<code>Github Pages</code>上时的每个<code>rake</code>命令都做了什么，后边会详述。</p>

<h3 id="setupoctopress">设置(Setup)Octopress</h3>

<p><code>clone</code>下Github上的<a href="https://github.com/imathis/octopress">octopress仓库</a></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git clone git://github.com/imathis/octopress.git octopress
</span><span class="line">cd octopress</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>然后安装相关依赖</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">gem install bundler
</span><span class="line">rbenv rehash    # 如果你使用的是rbenv, rehash 一下以确保能运行 bundle 命令
</span><span class="line">bundle install</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>安装默认Octopress主题</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake install</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="deploygithub-pages">部署(Deploy)到Github Pages</h3>

<p><a href="https://github.com/repositories/new">新创建</a>一个名字格式形如 <code>username.github.io</code> 的Github仓库，这里的<code>username</code>即你的Github用户名(或组织名)。</p>

<p>配置<code>Github Pages</code></p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake setup_github_pages</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>该命令会要求你输入上边所新建的Github仓库的<code>URL</code>。复制粘贴下你新创建仓库的<code>SSH</code>或<code>HTTPS</code> URL 即可(比如SSH的URL <code>git@github.com:username/username.github.io.git</code>)。</p>

<p>然后生成并部署站点</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake generate
</span><span class="line">rake deploy</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>最后不要忘记<code>commit</code>你<code>octopress框架</code>的源码(source)到服务器(关于这个<code>source</code>的具体含义后边详述)</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
</pre></td><td class="code"><pre><code class=""><span class="line">git add .
</span><span class="line">git commit -m 'your message'
</span><span class="line">git push origin source</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>OK，如果你按照上述命令一条一条来的话，到此博客已经搭建成功。可以在浏览器输入上述<code>username.github.io</code>验证一下。另外你也可以通过<a href="http://octopress.org/docs/deploying/github/#custom_domains">简单的配置</a>使用自己的独立域名(如果有的话)，这里不再赘述。</p>

<h3 id="section-2">下面来简单介绍一下怎么新建一篇文章</h3>

<p>创建一篇名为<code>"Hello World"</code>的文章</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake new_post["Hello World"]</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>如果直接<code>rake new_post</code>回车的话，会命令行提示输入博客名。</p>

<p>生成文章</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake generate   # 在互联网的公开目录生成文章的网页</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>预览新生成的文章</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake preview    # 生成blog预览</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>此时在浏览器中输入<code>http://localhost:4000</code>可预览刚生成的博客，但<code>Github Pages</code>上还看不到。</p>

<p>部署blog</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class=""><span class="line">rake deploy     # 部署blog到Github Pages</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>OK，一篇名为<code>"Hello World"</code>的博客已经发布到了<code>Github Pages</code>，可以在浏览器输入上述<code>username.github.io</code>验证一下。</p>

<p>到目前为止，关于怎样搭建博客和发布博客已经介绍完毕。看一下你本地的<code>octopress目录</code>和Github上的<code>username.github.io</code>仓库目录，如果你对他们的结构有所疑问，或者对上述<code>rake</code>命令究竟做了什么感到好奇，那么接着往下看。</p>

<h2 id="section-3">搭建过程详解</h2>

<p>在你本地的<code>octopress目录</code>下，静躺着一个名为<code>Rakefile</code>的文件，他就是今天的主角。该文件是用<code>Ruby</code>写的，如果你没接触过Ruby但对<code>shell</code>或<code>Python</code>较熟悉的话，基本上可以无障碍阅读该文件。</p>

<p>我们来看下<code>octopress目录</code>的结构，重点注意一下<code>_deploy</code>, <code>public</code>和<code>source</code>这三个子目录。再看一下你刚建的<code>username.github.io</code>仓库，注意下该仓库有两个分支，分别为<code>master</code>分支和<code>source</code>分支。注意了，这里的<code>master</code>分支所对应的本地分支在上述的<code>_deploy目录</code>下，而这里的<code>source</code>分支所对应的是本地分支即在上述的整个<code>octopress目录</code>下。下面我们根据<code>Rakefile</code>文件来分析上述各个<code>rake</code>命令具体都做了什么，然后我们就知道了这个结果是怎么发生的以及为什么要这么做。</p>

<p>这里所有的路径都是相对<code>octopress目录</code>来说的。</p>

<h3 id="rake-install">rake install</h3>

<p>初始化并配置<code>octopress</code>的主题，如果后边没跟主题名参数，则安装默认主题。该命令主要做了如下操作：</p>

<ol>
  <li>首先根据octopress是否已有<code>source</code>目录或<code>sass</code>目录来判断是否已安装了主题，如果已安装，则询问用户是否覆盖已有主题。如果否，则流程终止(<code>abort</code>)。</li>
  <li>该命令后边是可以再加一个可选的主题名的，否则会使用默认主题<code>Classic</code>。</li>
  <li>创建<code>source</code>目录，并将<code>"#{themes_dir}/#{theme}/source/."</code>目录下的文件拷贝到<code>source</code>目录。</li>
  <li>创建<code>sass</code>目录，并将<code>"#{themes_dir}/#{theme}/sass/."</code>目录下的文件拷贝到<code>sass</code>目录。</li>
  <li>创建<code>source/_posts</code>目录和<code>public</code>目录。</li>
</ol>

<h3 id="rake-setupgithubpages">rake setup_github_pages</h3>

<p><code>用户</code>或<code>组织</code>的<code>Github Pages</code>使用<code>master</code>分支作为<code>web服务</code>的公开目录，为你URL为<code>http://username.github.io</code>的Pages提供内容文件。因此，你会有这样一个需求，即在<code>source</code>分支上做一些与博客(或说<code>octopress框架</code>)源码相关的工作，而在<code>master</code>分支上<code>commit</code>已经生成的博客内容供web访问。该命令主要就是为我们完成上述任务，具体主要做了下述一系列操作。</p>

<p><strong>NOTE:</strong> 该命令主要用来生成并配置本地<code>octopress/_deploy</code>目录。下文中所提到的<code>Github Pages</code>仓库即下边首先要新建的这个名字形如<code>username.github.io</code>的仓库。</p>

<ol>
  <li>
    <p>要求输入你<code>Github Pages</code>仓库的<code>URL</code>。
该<code>URL</code>即此步之前你在Github上新建的那个命名格式为<code>username.github.io</code>的仓库的URL。之所以以这样的格式命名该仓库，是因为后边要通过该URL提取出该仓库名(即<code>username.github.io</code>)，以用来配置成你的Github Pages的域名，即你博客的域名。该URL有<code>SSH</code>和<code>HTTPS</code>两种格式，都很容易通过字符串截取拿到子串<code>"username.github.io"</code>。(Github之前使用<code>http://username.github.com</code>作为Github Pages的域名，后来将<code>.com</code>改为了<code>.io</code>，该<code>rake</code>脚本中对此做了兼容处理)。</p>
  </li>
  <li>
    <p>将指向<code>imathis/octopress</code>的远程库的名字由<code>origin</code>改为<code>octopress</code>。</p>

    <p><strong>NOTE:</strong> Git在clone一个仓库时会自动将我们从Git服务器上clone下来的仓库命名为origin，并下载其中所有的数据，建立一个指向该仓库的 master 分支的指针，在本地将其命名为 origin/master，但你无法在本地更改其数据。接着，Git 建立一个属于你自己的本地 master 分支，始于 origin 上 master 分支相同的位置，你可以就此开始工作。</p>

    <p>因此，当我们<code>clone</code>了octopress的仓库<code>git://github.com/imathis/octopress.git</code>后，远程仓库是这样的：</p>

    <pre><code> matrixzk:octopress matrixzk$ git remote -v
 origin     git://github.com/imathis/octopress.git (fetch)
 origin     git://github.com/imathis/octopress.git (push)
</code></pre>

    <p>这里为我们将远程仓库名由<code>origin</code>修改为<code>octopress</code></p>

    <pre><code> $ git remote rename origin octopress
</code></pre>

    <p>之后再查看远程仓库，可以看到<code>远程库</code>的名字已经改了</p>

    <pre><code> matrixzk:octopress matrixzk$ git remote -v
 octopress     git://github.com/imathis/octopress.git (fetch)
 octopress     git://github.com/imathis/octopress.git (push)
</code></pre>
  </li>
  <li>
    <p>添加你的<code>Github Pages</code>仓库作为当前本地仓库默认的远程仓库<code>origin</code></p>

    <pre><code> $ git remote add origin git@github.com:matrixzk/matrixzk.github.io.git
</code></pre>

    <p>然后将远程库中指向之前<code>origin</code>(即<code>imathis/octopress</code>)的<code>master</code>分支的<code>指针</code>指向现在的<code>origin</code>(即<code>matrixzk/matrixzk.github.io</code>)的<code>master</code>分支</p>

    <pre><code> $ git config branch.master.remote origin
</code></pre>

    <p>之后再查看远程库，可以看到已经将远程库<code>origin</code>指向了我们的<code>Github Pages</code>。</p>

    <pre><code> matrixzk:octopress matrixzk$ git remote -v
 octopress     git://github.com/imathis/octopress.git (fetch)
 octopress     git://github.com/imathis/octopress.git (push)
 origin     git@github.com:matrixzk/matrixzk.github.io.git (fetch)
 origin     git@github.com:matrixzk/matrixzk.github.io.git (push)
</code></pre>
  </li>
  <li>
    <p>将本地master分支的名字由<code>master</code>改为<code>source</code></p>

    <pre><code> $ git branch -m master source
</code></pre>

    <p>之后查看本地分支</p>

    <pre><code> matrixzk:octopress matrixzk$ git branch
 * source
</code></pre>

    <p><strong>NOTE:</strong> 理解这里很重要，关于这里为什么要这样做，要结合下边的6一起理解。前边已经提到，用户或组织的Github Pages使用master分支作为web服务的公开目录，为你URL为<code>http://username.github.io</code>的Pages提供网站内容(即内容文件)。而当前的本地<code>master</code>分支即整个<code>octopress框架</code>的源码所在的分支。其实本地的<code>master</code>分支就是一个名字为<code>master</code>的<code>指针</code>，它现在指向的是整个octopress框架的源码所在的本地分支。我们这里做的其实是把指向整个octopress框架的源码所在的本地分支的指针的名字由<code>master</code>改为<code>source</code>，把这个<code>master</code>指针名字让出来，让它指向后边6所初始化的用于<code>web访问</code>的<code>octopress/_deploy</code>目录下的本地仓库的主分支。这样，该目录(本地<code>octopress/_deploy</code>目录)下的本地<code>master</code>分支对应的就是<code>Github Pages</code>远程库的<code>master</code>分支。</p>
  </li>
  <li>
    <p>根据前边所提供的Github Pages仓库的URL来配置博客的URL
从前边所提供的SSH或HTTPS类型的URL中截取仓库名<code>username.github.io</code>，然后从本地的octopress目录下读取博客的配置文件<code>_config.yml</code>，将其<code>url</code>参数值改为<code>http://username.github.io</code>。</p>
  </li>
  <li>
    <p>在本地<code>octopress</code>目录下新建<code>_deploy</code>目录，并对其进行Git初始化，然后添加<code>Github Pages</code>仓库作为其远程仓库。</p>

    <p>NOTE:此时已经有了两个本地仓库(这个和前边3提到的整个<code>octopress</code>目录(即<code>octopress框架</code>)所对应的本地仓库)指向<code>Github Pages</code>仓库作为其远程仓库了，分别作为其<code>master</code>分支和<code>source</code>分支。</p>

    <pre><code> $ mkdir _deploy
 $ git init
 $ git add .
 $ git commit -m "Octopress init"
 # 添加Github Pages仓库作为其远程仓库
 $ git remote add origin git@github.com:matrixzk/matrixzk.github.io.git
</code></pre>

    <p>然后修改<code>Rakefile</code>中<code>deploy_default</code>和<code>deploy_brach</code>两个变量的初始默认值:</p>

    <pre><code> # 代表部署时执行的命令，该'push'为Rakefile中定义的一个rake task
 deploy_default = "push"   # 初始默认值"rsync"
 # This will be configured for you when you run config_deploy
 # 代表部署时执行上述rake task命令’push'时的操作分支
 deploy_branch  = "master" # 初始默认值"gh-pages"
</code></pre>
  </li>
</ol>

<h3 id="rake-generate">rake generate</h3>

<p>生成<code>jekyll</code>站点</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class=""><span class="line">compass compile --css-dir source/stylesheets
</span><span class="line">jekyll build</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="rake-preview">rake preview</h3>

<p>对修改后的站点(如新写了一篇文章)生成预览，在浏览器中输入<code>http://localhost:4000</code>可看到预览效果。</p>

<h3 id="rake-deploy">rake deploy</h3>

<p>将站点部署到服务器，即发布站点到互联网。由于<code>_deploy</code>目录所代表的本地仓库的<code>master</code>分支对应<code>Github Pages远程仓库</code>的<code>master</code>分支，该分支目录的内容即<code>Github Pages</code>在互联网上供公开访问的站点内容。因此这里做的主要就是将新写的博客文章copy到<code>_deploy</code>目录下，然后将此修改<code>push</code>到<code>Github Pages</code>远程库的<code>master</code>分支。</p>

<ol>
  <li>首先查看是否存在预览模式的博客(它们不该被发布)，如果有则删除，并在此重新执行<code>rake generate</code>。</li>
  <li>将<code>source</code>目录下的文件拷贝到<code>public</code>目录下。</li>
  <li>进入<code>_deploy</code>目录，执行<code>git pull</code>操作。</li>
  <li>将<code>public</code>目录的内容拷贝到<code>_deploy</code>目录下。</li>
  <li>将<code>_deploy</code>目录所对应的本地master分支的修改<code>push</code>到Github Pages远程库的master分支，即将Github Pages即你的博客部署到了互联网。这里主要做了如下操作。</li>
</ol>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">$ cd _deploy
</span><span class="line">$ git add -A
</span><span class="line">$ git commit -m "Site updated at #Time.now(即当前时间)"
</span><span class="line">$ git push origin master  # Pushing generated _deploy website</span></code></pre></td></tr></table></div></figure></notextile></div>

<h3 id="github-pagessource">生成Github Pages远程库的source分支</h3>

<p>搭建过程的最后一步是将你本地<code>octopress框架</code>的源码(即本地的<code>source</code>分支)<code>push</code>到<code>Github Pages</code>远程库。注意，此步之前Github Pages远程库还不存在<code>source</code>分支。</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
</pre></td><td class="code"><pre><code class=""><span class="line">cd octopress
</span><span class="line">git add .
</span><span class="line">git commit -m 'your message'
</span><span class="line">git push origin source # 注意，此时你本地的source分支push到远程库，之后远程库会生成一个source分支</span></code></pre></td></tr></table></div></figure></notextile></div>

<p><strong>NOTE:</strong> 这里所做的是将本地<code>octopress</code>目录下的本地<code>source</code>分支(前边已将该默认分支名由<code>master</code>改为<code>source</code>)<code>push</code>到Github Pages远程库，这样，<code>Github Pages</code>远程库就生成了<code>source</code>分支。至此，<code>Github Pages</code>远程库有了两个分支，即<code>master</code>分支和<code>source</code>分支。这里的<code>master</code>分支所对应的本地分支为本地的<code>octopress/_deploy</code>目录下本地仓库的<code>master</code>分支，主要存放部署完毕生成的供互联网访问的<code>Github Pages</code>站点(即你的博客站点)的内容。<code>source</code>分支所对应的本地分支为本地的整个<code>octopress</code>目录下本地仓库的<code>source</code>分支(即该本地库的主分支，之前将其名字有<code>master</code>改为了<code>source</code>，缘由前边已详述)，主要存放整个<code>octopress框架</code>源码的内容。</p>

<h3 id="rake-newposthello-world">rake new_post[“Hello World”]</h3>

<p>新建一篇博客。这里以新建一篇名为<code>"Hello World"</code>的blog为例。</p>

<ol>
  <li>
    <p>判断是否提供了文章title，如果没给的话提示输入title。</p>
  </li>
  <li>
    <p>在<code>source/_posts</code>目录下创建名字为<code>"2014-10-17-hello-world.markdown"</code>的文件，即你新建的博客文章。新建博客的命名规则为<code>YYYY-MM-DD-post-title.markdown</code>。</p>

    <pre><code> filename = "#{source_dir}/#{posts_dir}/#{Time.now.strftime('%Y-%m-%d')}-#{title.to_url}.#{new_post_ext}"
</code></pre>

    <p><strong>NOTE:</strong> 如果相同文件名的文件已经存在，会询问你是否覆盖原文件，如果否，则流程终止(<code>abort</code>)。这里所说相同文件名指的是自动生成的时间也相同。这个时间的作用，一是用来区分相同名字(<code>post title</code>)的文章，二是用来为决定博客文章列表的顺序。</p>
  </li>
  <li>
    <p>在新建的<code>"2014-10-17-hello-world.markdown"</code>文件开头写入如下内容</p>

    <pre><code> ---
 layout: post
 title: "hello world"
 date: 2014-10-17 19:59
 comments: true
 external-url:
 categories:
 ---
</code></pre>

    <p>这段<a href="http://jekyllrb.com/docs/frontmatter/">yaml front matter</a>主要是告诉<code>jekyll</code>你新建博客的一些生成规则。这里可以让你关掉评论功能，或者给你新建的文章添加分类。如果你在与多个作者同时维护一个博客，添加<code>author: Your Name</code> 到上述脚本中可以在适当的位置显示你的名字。如果你在写一篇草稿，添加<code>published: false</code>可以防止在你生成(<code>generate</code>)博客时把这篇草稿发布出去。如果你要发布一篇链接博客(<code>linklog</code>)，即点击标题后会跳转到另一个站点的某篇文章，只需将<code>external-url</code>参数值设为指定站点文章的<code>url</code>即可，例如：</p>

    <pre><code> external-url: http://opinionguy.com/post/uninformed-rant-vs-straw-man/
</code></pre>

    <p>按如下方式可以给你新建文章添加一或多个类别(<code>category</code>)。</p>

    <pre><code> # 一个category
 categories: Sass
 # 多个categories的例子1
 categories: [CSS3, Sass, Media Queries]
 # 多个categories的例子2
 categories:
 - CSS3
 - Sass
 - Media Queries
</code></pre>
  </li>
</ol>

<hr />

<p>好了，到此为止已经将使用<code>octopress</code>搭建基于<code>Github Pages</code>个人博客的整个过程和边边角角都介绍了。有些命令和术语可能理解得不够准确，欢迎指正。</p>
]]></content>
  </entry>
  
</feed>

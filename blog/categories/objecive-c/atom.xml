<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[分类：objecive-c | Matrixzk's Blog]]></title>
  <link href="http://matrixzk.github.io/blog/categories/objecive-c/atom.xml" rel="self"/>
  <link href="http://matrixzk.github.io/"/>
  <updated>2015-06-26T21:43:24+08:00</updated>
  <id>http://matrixzk.github.io/</id>
  <author>
    <name><![CDATA[matrixzk]]></name>
    <email><![CDATA[matrixzk.me@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ARC 下向 NSArray 添加 Block 元素的一个小坑]]></title>
    <link href="http://matrixzk.github.io/blog/20150518/store_blocks_in_NSArray/"/>
    <updated>2015-05-18T15:51:44+08:00</updated>
    <id>http://matrixzk.github.io/blog/20150518/store_blocks_in_NSArray</id>
    <content type="html"><![CDATA[<p>一直以来我都认为在 ARC 下，给 Cocoa 框架的集合类，如 NSArray，添加 Block 类型的元素时，Block 是会被编译器自动执行 <code>copy</code> 操作的。而且一直以来的实践也验证了这一事实。但今天在测试如下一段代码时出现了问题。</p>

<!-- more -->

<ul id="markdown-toc">
  <li><a href="#section">问题描述</a></li>
  <li><a href="#section-1">测试验证</a></li>
  <li><a href="#section-2">探寻原因</a></li>
  <li><a href="#section-3">扩展</a></li>
</ul>

<h2 id="section">问题描述</h2>

<p>先看下出问题的测试代码：</p>

<p>&#8220;`objc
id getBlockArray() {
    int val = 12;
    NSArray *arr = [[NSArray alloc] initWithObjects:^{NSLog(@”block1 val = %d”, val);},
                                                    ^{NSLog(@”block2 val = %d”, val);},
                                                    nil];
    return arr;
}</p>

<p>typedef void (^MyBlock)(void);</p>

<p>int main(int argc, const char * argv[]) {</p>

<pre><code>id blkArray = [obj getBlockArray];
MyBlock block1 = blkArray[0];
MyBlock block2 = blkArray[1]; // EXC_BAD_ACCESS, crash !!!

blcok1();
blcok2();

return 0; } ```
</code></pre>

<p>如上所示，在获取数组中第二个 Block 元素时，crash 了，原因是 <code>EXC_BAD_ACCESS</code>，即访问了已被释放的无效内存。很奇怪，调试打印 <code>arr</code>，输出如下：</p>

<p><code>
&lt;__NSArrayM 0x100300500&gt;(
    &lt;__NSMallocBlock__: 0x100300410&gt;,
    &lt;__NSStackBlock__: 0x7fff5fbff750&gt;
)
</code></p>

<p>居然一个在堆上，一个在栈上，这。。。有些挑战三观了。</p>

<h2 id="section-1">测试验证</h2>

<p>确实很奇怪，那不妨来试试给数组填充元素的其他方式吧：</p>

<p>&#8220;`
- (id)getBlockArray {
    int val = 10;</p>

<pre><code>NSMutableArray *arr = [[NSMutableArray alloc] init];
[arr addObject:^{NSLog(@"block1 val = %d", val);}];
[arr addObject:^{NSLog(@"block2 val = %d", val);}];

return arr; }  ```
</code></pre>

<p>以及：</p>

<p><code>
int val = 10;
NSArray *arr = @[^{NSLog(@"block1 val = %d", val);}, ^{NSLog(@"block2 val = %d", val);}];
</code></p>

<p>这两种情况下调试打印 <code>arr</code>，输出如下：</p>

<p><code>
&lt;__NSArrayM 0x100100250&gt;(
    &lt;__NSMallocBlock__: 0x100200550&gt;,
    &lt;__NSMallocBlock__: 0x1003007e0&gt;
)
</code></p>

<p>可以看到都没问题，作为 <code>addObject:</code> 参数添加进来的两个 Block 元素，都被编译器自动执行了 <code>copy</code> 操作，这样 Block 的类型就变成了 <code>__NSMallocBlock</code>，被拷贝到了堆上。好险，三观稍微又正了点儿。但文章开头的问题究竟是什么原因呢？</p>

<h2 id="section-2">探寻原因</h2>

<p>比较上边的测试代码和出问题的代码，同样都是 ARC 的测试环境，为什么问题代码中数组的两个 Block 元素，第一个在堆上，第二个在栈上呢？联想到像测试代码中这样，将 Block 拷贝到堆上的操作是编译器在编译时完成的，那问题会不会出在初始化方法上呢？然后点开出问题的那个 API：</p>

<p><code>
- (instancetype)initWithObjects:(id)firstObj, ... NS_REQUIRES_NIL_TERMINATION;
</code></p>

<p>果然！这里的参数是可变个数的，而且只有第一个参数显式的声明为 <code>id</code> 类型。这下就能解释问题代码中，为什么第一个 Block 元素在堆上而第二个却在栈上：因为只有第一个参数显式的声明为 <code>id</code> 类型，所以编译器在编译阶段只能意识到需要对第一个作为参数传进来的 Block 进行 <code>copy</code> 处理。为了验证这一猜测，下面显式得把后边的 Block 传参强制转换为 <code>id</code> 类型，让编译器<code>看到</code>它：</p>

<p><code>
NSArray *arr = [[NSArray alloc] initWithObjects:^{NSLog(@"block1 val = %d", val);},
                                                (id)^{NSLog(@"block2 val = %d", val);},
                                                nil];
</code></p>

<p>代码顺利运行通过，没有 crash，猜测得到了验证。这真算是一个坑点儿。在 stackoverflow 上看到了一个对类似问题的讨论，可以参考下：<a href="http://stackoverflow.com/questions/7997666/storing-blocks-in-an-array">Storing Blocks in an Array</a>。</p>

<h2 id="section-3">扩展</h2>

<p>另外需要注意的一点是，在 MRC 下，向方法或函数的参数中传递 Block 时，除了以下两种情况，都需要手动 <code>copy</code> 一下：</p>

<ul>
  <li>Cocoa 框架中的方法名含有 usingBlock 的方法。例如 NSArray 的 <code>enumerateObjectsUsingBlock</code> 实例方法。</li>
  <li>GCD 的 API。例如，<code>dispatch_async</code> 函数。</li>
</ul>

<p>在 ARC 下，除了上述两种情况外，在如下两种情况，编译器也帮我们自动做了 <code>copy</code> 操作：</p>

<ul>
  <li>Block 作为函数或方法的返回值返回时。(此场景和 ARC 下普通的对象作为函数或方法返回值返回时的场景一致)</li>
  <li>将 Block 赋值给附有 <code>__strong</code> 修饰符的变量时。(ARC 下的局部变量和成员变量默认都是 <code>__strong</code> 的，只是作用域不同)</li>
</ul>

<p>这里还有一个有趣的小测试<a href="http://blog.parse.com/learn/engineering/objective-c-blocks-quiz/">Objective-C Blocks Quiz</a>，可以测下自己对 Block 的理解。</p>

]]></content>
  </entry>
  
</feed>


<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Matrixzk&#8217;s Blog</title>
  <meta name="author" content="matrixzk">

  
  <meta name="description" content="一直以来我都认为在 ARC 下，给 Cocoa 框架的集合类，如 NSArray，添加 Block 类型的元素时，Block 是会被编译器自动执行 copy 操作的。而且一直以来的实践也验证了这一事实。但今天在测试如下一段代码时出现了问题。 ">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://matrixzk.github.io">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Matrixzk's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <!--
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <!-->
  <script src="//ajax.useso.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<!-->

<link href="http://fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-56261327-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Matrixzk&#8217;s Blog</a></h1>
  
    <h2>keep moving</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="订阅RSS">RSS</a></li>
  
</ul>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><font color=#f2f2f2>|</font></li>
  <li><a href="/blog/archives">所有文章</a></li>
  <li><font color=#f2f2f2>|</font></li>
  <li><a href="/about/about.html">关于我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20150518/store_blocks_in_NSArray/">ARC 下向 NSArray 添加 Block 元素的一个小坑</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
May 18th, 2015
        
      </p>
    
  </header>


  <div class="entry-content"><p>一直以来我都认为在 ARC 下，给 Cocoa 框架的集合类，如 NSArray，添加 Block 类型的元素时，Block 是会被编译器自动执行 <code>copy</code> 操作的。而且一直以来的实践也验证了这一事实。但今天在测试如下一段代码时出现了问题。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20150518/store_blocks_in_NSArray/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20150122/load-image-encoded-with-base64/">在 iOS 中展示 Base64 编码的图片</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
Jan 22nd, 2015
        
      </p>
    
  </header>


  <div class="entry-content"><p>做网页前端的同学有时为了减少 Http 的请求数量，经常会把一些需要重复使用并且比较小的图片根据 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/data_URIs">Data URI</a> 协议，经 <a href="http://zh.wikipedia.org/wiki/Base64">base64</a> 编码成字符串格式来储存。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20150122/load-image-encoded-with-base64/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20150110/resolve-gesture-conflicts/">解决 UIPanGestureRecognizer 和 UIScreenEdgePanGestureRecognizer 手势的冲突问题</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
Jan 10th, 2015
        
      </p>
    
  </header>


  <div class="entry-content"><p>有这样一个场景。现在想给一个 ViewController 容器增加一个手势，触发前进后退的导航功能。正常情况下，这里用 UIPanGestureRecognizer 就可以了。但是存在一个问题，如果当前界面有一个可以左右滑动的 ScrollView 时，比如是一个被双指放大了的 WebView，那么所加的这个 pan 手势就会被 ScrollView 的内部手势 (UIScrollViewPanGestureRecognizer 类型) 给屏蔽掉而不会被触发。于是这里又添加了两个 UIScreenEdgePanGestureRecognizer 边缘滑动手势，以在上述情况下通过触发边缘滑动手势进行前进后退导航。这时问题就来了，这几个手势势必会存在冲突问题 (其实真实项目中这里还有一个自定义的上下滑动手势，不过这里就先不提它了，主要说说上述两个手势的冲突问题)。下面就来解决这个问题。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20150110/resolve-gesture-conflicts/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20141220/crash-file-analysis/">简述 Crash 文件分析流程</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
Dec 20th, 2014
        
      </p>
    
  </header>


  <div class="entry-content"><p>虽然现在已经有很多第三方的服务能帮你分析线上 App 的 Crash 文件，但有时还是难免要对单独某个 Crash 文件做分析，本文就是来介绍一下这个流程。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20141220/crash-file-analysis/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20141113/memory-management-3-autoreleasePool/">OC内存管理那些事儿(3)：使用自动释放池块</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
Nov 13th, 2014
        
      </p>
    
  </header>


  <div class="entry-content"><p>自动释放池块提供了一种机制，通过它我们在放弃一个对象的所有权时，可以避免该对象被立即释放掉(就像从一个方法返回一个对象那样)。通常情况下不需要创建自己的自动释放池的，但有些特殊情况就必须或者说有必要这样做。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20141113/memory-management-3-autoreleasePool/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20141111/memory-management-2-practical/">OC内存管理那些事儿(2)：内存管理实践</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
Nov 11th, 2014
        
      </p>
    
  </header>


  <div class="entry-content"><p>虽然<a href="/blog/20141109/memory-management-1-policy/"><strong>上篇文章</strong></a>中所介绍的基本概念简单明了，但仍有一些实用的套路可使内存管理更加简单，而且能帮忙确保在最大限度得减少资源需求的同时，程序依然能够可靠健壮得运行。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20141111/memory-management-2-practical/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20141109/memory-management-1-policy/">OC内存管理那些事儿(1)：内存管理策略</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
Nov 9th, 2014
        
      </p>
    
  </header>


  <div class="entry-content"><p>在引用计数环境下用于内存管理的基本模型，是由 <strong>NSObject</strong> <code>protocol</code>中所定义的一些方法，结合一套标准的方法命名约定共同提供的。<strong>NSObject</strong> 类还定义了一个<code>dealloc</code>方法，该方法会在对象被释放时自动调用。本文将讲解在 Cocoa 编程中所需了解的关于正确进行内存管理的基本规则，并提供一些正确用法的示例。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20141109/memory-management-1-policy/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20141107/memory-management-0-introduction/">OC内存管理那些事儿(0)：关于内存管理</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
Nov 7th, 2014
        
      </p>
    
  </header>


  <div class="entry-content"><p>不论哪门编程语言，内存管理都一直是一个广受关注的问题，包括有垃圾回收机制的 Java (前几天还听几个搞 Android 的小伙伴在热切的讨论 Java 中的内存管理)。作为有节操的 iOS 开发者，大家对内存管理问题更是时刻保持着高度的使命感。这两年新开的项目可能都已经使用 <code>ARC</code> ( Automatic Reference Counting )了。想想自己刚从 <code>MRR</code> ( manual retain-release ) 往 <code>ARC</code> 过渡那会儿，虽然苹果官方一再强调可以放心得使用 <code>ARC</code>，但由于在 <code>ARR</code> 下谨慎惯了，一时还是不太敢放心的把内存管理全都交给编译器去做。现在再看 <code>ARC</code>，确实是个可以放心托付的家伙，而且它在编译器级对内存管理做了更进一步的优化。其实当苹果在 Xcode 中内置了强大的静态分析器( Clang Static Analyzer )时我就想，既然内存泄漏隐患都能在编译阶段这么精准得定位到，为什么不更进一步直接把它们解决了呢。后来果然不久苹果就推出了强大的 <code>ARC</code> 机制，直接帮开发者把内存管理的事儿给做了，真是家强大的公司。虽然在 <code>ARC</code> 下不用太过多的关注内存管理问题，但是对 OC 的内存管理机制有一个深刻的理解还是非常有必要的，而且有时你也可能不得不去维护由于历史原因还在使用 <code>MRR</code> 的项目。</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20141107/memory-management-0-introduction/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20141104/git-flow-model/">一个完美的 Git 分支管理模型 (Git工作流)</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
Nov 4th, 2014
        
      </p>
    
  </header>


  <div class="entry-content"><p>众所周知，<a href="http://git-scm.com/">Git</a> 是目前最优秀的版本控制工具。但很多团队在使用Git进行协作开发的过程中，并没有形成一个清晰规范的流程。本文的作者<a href="http://nvie.com/"> Vincent Driessen </a>向我们介绍了一个相对比较完美的分支管理策略，依照这个策略基本可以保证团队开发和版本发布有条不紊得进行。Vincent Driessen还据此实现了一个 Git 扩展集<a href="https://github.com/nvie/gitflow"> git-flow </a>，它为本文所介绍的分支管理模型提供了一些较高层次的<code>repository operations</code>(库操作)。其本质是对下文所述的相关Git命令集进行进一步封装，并提供一些友好的命令行提示，具体可参考<a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html"> git-flow 备忘清单</a>。本文译自<a href="http://nvie.com/posts/a-successful-git-branching-model/"> A successful Git branching model </a>，推荐原汁原味的阅读。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20141104/git-flow-model/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/20141103/octopress-custom-config/">Octopress 主题修改小记</a></h1>
    
    
      <p class="meta">
        
<!-- post.date_time_html -->



<!--


<!-->
Nov 3rd, 2014
        
      </p>
    
  </header>


  <div class="entry-content"><p>博客搭建起来后，总感觉默认的 classic 主题有些呆板，而且字体太大，阅读体验不是很好。于是就尝试着更改下主题。把 Octopress 的<strong><a href="https://github.com/imathis/octopress/wiki/3rd-Party-Octopress-Themes">推荐主题</a></strong>浏览了一遍后发现<a href="https://github.com/shashankmehta/greyshade"> Greyshade </a>的效果还不错。但是安装后发现该主题有些细节还是不尽如人意，比如字体大小、行高、代码高亮背景，等等。经过一番调试后总算基本满意了，但是用移动设备打开后，顿时碎了。它的样式对移动设备真是差劲，比如代码高亮字体大小不一、左右滑动后右边有一条不窄的黑边并且消不去、左侧边栏在 iPad 上不能很好的适应，等等等等。相比之下 Octopress 的默认主题对移动设备的支持就要好太多，几乎完美，而且由于样式不花哨，很好的突出了内容主体。也许这就是这个主题的设计初衷吧，以内容为主体，淡化样式。对于博客来说，阅读体验才是重中之重，而且在这个移动互联网的时代，对移动设备的支持也必须到位。出于以上考虑，我又换回了默认的 classic 主题，但决定对其进行个性化改造。
</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/20141103/octopress-custom-config/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    <!--
    
      <a class="prev" href="/posts/2">&larr; 最近</a>
    
    <a href="/blog/archives">所有文章</a>
    
    <!-->
    
    
    

    <a href="/blog/archives">所有文章</a>

    
    <a class="next" href="/posts/2">更早 &rarr;</a>
    
    

  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>最新文章</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/20150518/store_blocks_in_NSArray/">ARC 下向 NSArray 添加 Block 元素的一个小坑</a>
      </li>
    
      <li class="post">
        <a href="/blog/20150122/load-image-encoded-with-base64/">在 iOS 中展示 Base64 编码的图片</a>
      </li>
    
      <li class="post">
        <a href="/blog/20150110/resolve-gesture-conflicts/">解决 UIPanGestureRecognizer 和 UIScreenEdgePanGestureRecognizer 手势的冲突问题</a>
      </li>
    
      <li class="post">
        <a href="/blog/20141220/crash-file-analysis/">简述 Crash 文件分析流程</a>
      </li>
    
      <li class="post">
        <a href="/blog/20141113/memory-management-3-autoreleasePool/">OC内存管理那些事儿(3)：使用自动释放池块</a>
      </li>
    
  </ul>
</section>
<section>
  <br/>
  <h1>分类目录</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/git/'>git (1)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (2)</a></li>
<li class='category'><a href='/blog/categories/ios8-day-by-day/'>ios8 day-by-day (1)</a></li>
<li class='category'><a href='/blog/categories/octopress/'>octopress (2)</a></li>
<li class='category'><a href='/blog/categories/ocnei-cun-guan-li/'>oc内存管理 (4)</a></li>

  </ul>
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2015 - matrixzk -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











  <!--返回顶部开始-->
<div id="full" style="width:0px; height:0px; position:fixed; right:60px; bottom:60px; z-index:100; text-align:right; background-color:transparent; cursor:pointer;">
        <a href="#" onclick="goTop();return false;"><img src="/images/top.png" border=0 alt="返回顶部"></a>
</div>
<script src="/javascripts/goTop.js" type="text/javascript"></script>
<!--返回顶部结束-->
</body>
</html>

